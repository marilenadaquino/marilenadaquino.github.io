<!DOCTYPE HTML>
<!--
	Paradigm Shift by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Marilena Daquino</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<meta name="description" content="" />
		<meta name="keywords" content="open citations" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">
				<section class="intro">
					<header>
						<h1>Reports</h1>
						<p>about activities, progresses, and unicorns (almost)</a></p>
						<sub><a href="index.html">[back]</a></sub>
					</header>
					<div class="content">
						<span class="image fill" data-position="center"><img src="images/raccoonicorn.jpg" alt="" /></span>
					</div>
				</section>
				<section id="w22">
					<header>
						<h2>#w22</h2>
					</header>
					<div class="content">
						<p><strong>December 2, 2019 - December 6, 2019</strong></p>
						<h3>work on spacin</h3>
						<p>Tested new configuration of SPACIN on the test JSON dataset. everything works fine so far, I need to integrate the bit including the transformation of in-text ref pointers.</p>
						<p>Work plan:</p>
						<ol>
							<li>work on the provenance, to be reviewed according to the new OCDM document: ATM cleaning the code, removing entities/properties deprecated in the new version of OCDM, and testing.</li>
							<li>work on the URI design pattern, to cleraly identify which entities have to be renamed and how to deal with new entities (citations, annotations, rp, pl, de, etc.)</li>
							<li>work on the transformation of new entities in a bespoke method to be included in <code>jats2oc.py</code> (ATM it includes a method that creates all the data from scratch, without using SPACIN. Needs some cut and paste)</li>
						</ol>
					</div>

				</section>
				<section id="w21">
					<header>
						<h2>#w21</h2>
					</header>
					<div class="content">
						<p><strong>November 25, 2019 - November 29, 2019</strong></p>
						<p>I created a test dataset of JSONs extracted with BEE (including all the reference pointers and the other other information previously discussed) and I started planning the work
						for integrating SPACIN (identifying which parts have to be modified, how they interact and how to finalise the changes).</p>
						<p>We agreed to modify as less as possible SPACIN scripts (by adding only one parameter <em>intext_refs=False</em>) so as to not interfeer with Fabio's work on <em>META</em>.</p>
						<p>The idea is the following:</p>
<pre>
	<code>
<strong>ccc/run_spacin.py</strong>
	| <em>calls</em>
	<strong>spacin/crossrefproc.py#CrossrefProcessor()</strong>
	| <em>ADDED parameter <u>intext_refs=False</u></em> # added also in FormatProcessor()
	| <em>calls</em>
	<strong>spacin/crossrefproc.py#process()</strong>
		| <em>calls</em>
		<strong>spacin/crossrefproc.py#process_citing_entity()</strong>
		|	| <em>calls</em>
		|	<strong>spacin/crossrefproc.py#process_references()</strong>
		|		<em>ADD <u>xml_id</u> as identifier of cited sources</em>
		| <em>ADD If clause <u>intext_refs=True</u></em>
		| <em>calls</em>
		<strong>ccc/jats2oc.py#intext_refs_to_rdf()</strong>
	</code>
</pre>

					<h3>TODO</h3>
					<ul>
						<li>clean <code>Prov</code></li>
					</ul>

					</div>
				</section>
				<section id="w18">
					<header>
						<h2>#w18</h2>
					</header>
					<div class="content">
						<p><strong>November 4, 2019 - November 8, 2019</strong></p>
						<p>Finalizing the script for integrating bee, including all the aforementioned exceptions.
							I had some trouble in finding a good solution for getting the XPATH/string of lists that
							are neither in a parent element nor in separators. E.g. <code>xref/sup + sup=, +xref/sup + sup=, + xref/sup</code>.
						XPATH returns only a node-set, unfortunately doesn't match groups of elements. In the end I get the xpath of the string as we do for lists in separators.</p>
						<p>I sorted the list of rp incrementally. For the sake of simplicity, I decided to keep the incremental number in the final JSON [TO BE DISCUSSED]</p>
					</div>
				</section>
				<!-- Section -->
				<section id="w15">
					<header>
						<h2>#w15</h2>
					</header>
					<div class="content">
						<p><strong>October 14, 2019 - October 18, 2019</strong></p>
						<p>Found other exceptions in the subset of OA-PMC - for the sake of completeness, exceptions are recorded in the <a href="#exceptions_table">table</a> below). Mainly they regard the markup of lists and sequences. Currently, such exceptions are handled by ensuring that at least <em>all single pointers</em> are extracted regardless these are in lists or not, so as to ensure completeness of extracted pointers rather than precision in locating them in lists</p>
						<p>In the future I'll improve the script so as to handle all the exceptions iteratively (my test case will be the paper <a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31532339/fullTextXML">31532339</a> which includes all the possible inconsistencies allowed by JATS schema)</p>

						<p>[UPDATE 18.10.2019] I'm completely refactoring the code so as to handle 99% of exceptions one-by-one.</p>

						<h3>Exceptions table</h3>
						<p>
							<table id="exceptions_table">
								<thead>
									<th>path</th>
									<th>description</th>
									<th>example XML</th>
									<th>status</th>
								</thead>
								<tr>
									<td><code>sup/xref[@ref-type]</code></td>
									<td></td>
									<td><a href="https://www.ebi.ac.uk/europepmc/webservices/rest/30899012/fullTextXML">30899012</a></td>
									<td>[DONE]</td>
								</tr>
								<tr>
									<td><code>xref[@ref-type]/sup</code> </td>
									<td></td>
									<td></td>
									<td>[DONE]</td>
								</tr>
								<tr>
									<td><code>'('+xref[@ref-type]+')'</code> or <code>'['+xref[@ref-type]+']'</code></td>
									<td></td>
									<td></td>
									<td>[DONE]</td>
								</tr>
								<tr>
									<td><code>'['+xref[not(@ref-type)]+']'</code></td>
									<td></td>
									<td></td>
									<td>[DONE]</td>
								</tr>
								<tr>
									<td><code>xref[@ref-type][@rid='xx']/sup[/text() = 'xx-yy']</code></td>
									<td>the text identifies a sequence but only the first ref@id is recorded in @rid </td>
									<td> <a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31537132/fullTextXML">31537132</a> [TEST 3][TEST 4]</td>
									<td>[extracting only the xref with @rid]</td>
								</tr>
								<tr>
									<td><code>xref[@ref-type]/sup + sup[/text() = ','] + xref[@ref-type]/sup</code></td>
									<td>list</td>
									<td><a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31322015/fullTextXML">31322015</a> [TEST 4]</td>
									<td>[WIP, ATM extract all as rp]</td>
								</tr>
								<tr>
									<td><code>xref[@rid][@ref-type="bibr"][italic]/text()</code> </td>
									<td>contains comma (e.g. <pre><code>Amass <italic>et al.</italic>, 2000</code></pre>); may be wrapped in a <code>attrib</code> element; inconsistency in the usage of separators (sometimes there are, sometimes do not)</td>
									<td><a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31532339/fullTextXML">31532339</a> [TEST 2]</td>
									<td>[ATM extracting only rp, ignoring the rest]</td>
								</tr>
								<tr>
									<td><code>"["+ xref + "," + xref + "-" + xref +"]"</code></td>
									<td>list and sequence in the same group</td>
									<td><a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31243649/fullTextXML">31243649</a></td>
									<td>[ATM do not extract intermediate rp of sequences]</td>
								</tr>
								<tr>
									<td>"("+ xref[contains=')']</td>
									<td>the end separator is inconsistently put in/outside the xref, which results in very long lists</td>
									<td><a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31251352/fullTextXML">31251352</a></td>
									<td>[WIP]</td>
								</tr>
								<tr>
									<td>xref/sup+","+sup/xref +"," +xref</sup></td>
									<td>xref/sup and sup including several xref</td>
									<td><a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31257432/fullTextXML">31257432</a> [TEST 4]</td>
									<td>[WIP]</td>
								</tr>
								<tr>
									<td>"("+xref+"; blablabla"+xref+")"</td>
									<td>xrefs included in a list group, but long text other than in-list separator.</td>
									<td><a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31257432/fullTextXML">31257432</a> [TEST 4]</td>
									<td>[DONE]</td>
								</tr>
								<tr>
									<td>
										<code><xref rid="dkz261-B6" ref-type="bibr">
<sup>6</sup>
</xref>
<sup>,</sup>
<xref rid="dkz261-B34" ref-type="bibr">
<sup>34–36</sup>
</xref></code>
									</td>
									<td>sequence nested in list</td>
									<td><a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31257432/fullTextXML">31257432</a> [TEST 4]</td>
									<td>This I can't. I can get the 6 alone and the 34-36 as a list separately, but not both together</td>
								</tr>
							</table>
						</p>
					</div>
				</section>

				<!-- Section -->
				<!-- <section id="w">
					<header>
						<h2>#w</h2>
					</header>
					<div class="content">
						<p><strong>date - date</strong></p>
					</div>
				</section> -->
				<!-- Section -->
				<section id="w14">
					<header>
						<h2>#w14</h2>
					</header>
					<div class="content">
						<p><strong>October 7, 2019 - October 11, 2019</strong></p>
						<h3>Integration of BEE, citation styles checks</h3>
						<p>Here below a schema of the main changes in BEE.</p>
<pre>
	<code>
<strong>ccc/run.py</strong>
	| <em>calls</em>
	<strong>bee/epmcproc.py#EuropeanPubMedCentralProcessor()</strong>
	| <em>ADDED parameter <u>intext_refs=False</u></em>
	| <em>calls</em>
	<strong>bee/epmcproc.py#process()</strong>
		| <em>calls</em>
		<strong>bee/epmcproc.py#process_article() </strong>
		|	|	<em>ADDED parameter <u>intext_refs=False</u></em>
		|	|	<em>l.90 call to process_xml_source(<u>intext_refs=True</u>)</em>
		|	| <em>calls</em>
		|	<strong>bee/epmcproc.py#process_xml_source()</strong>
		|		<em>ADDED parameter <u>intext_refs=False</u></em>
		|		<em>l.306 call to JATS2OC class to fill</em>
		|		<em><u>self.rs.ref_pointer_list</u></em>
		|		<em>ll. 265, 303-311 ADDED <u>ref_xmlid</u></em>
		| <em>calls</em>
		<strong>bee/refstorer.py</strong>
			|	<em>l.67 ADDED method <u>new_ref_pointer_list()</u></em>
			<strong>bee/refstorer.py#add_reference()</strong>
			|	<em>l.78 ADDED parameter <u>ref_xmlid</u> and new k:v in "references"</em>
			<strong>bee/refstorer.py#store()</strong>
			|	<em>l.129 ADDED the JSON snippet</em>
			|	<em><u>json_item["reference_pointers"] = self.ref_pointer_list</u></em>
	</code>
</pre>
						<p>Still working on recognizing all the exceptions in reference pointer citation styles in OA-PMC. ATM we have the following scenarios:</p>
						<ul id="exceptions_oa">
							<li>
								<code>sup/xref[@ref-type]</code>
								e.g. <a href="https://www.ebi.ac.uk/europepmc/webservices/rest/30899012/fullTextXML">30899012</a> [DONE]
							</li>
							<li>
								<code>xref[@ref-type]/sup</code>
								[DONE]
							</li>
							<li>
								<code>'('+xref[@ref-type]+')'</code> or <code>'['+xref[@ref-type]+']'</code>
								[DONE]
							</li>
							<li>
								<code>'['+xref[not(@ref-type)]+']'</code>
								[DONE]
							</li>
							<li>
								<code>xref[@ref-type][@rid='xx']/sup[/text() = 'xx-yy']</code>
								meaning the text identifies a sequence but only one ref@id is recorded in @rid
								[WIP, ignoring the text ATM and extracting only the xref with @rid]
							</li>
							<li>
								<code>xref[@ref-type]/sup + sup[/text() = ','] + xref[@ref-type]/sup</code> to make a list e.g. <a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31322015/fullTextXML">31322015</a>
								[WIP, at the moment I consider them single pointers]
							</li>
							<li>
								<code>xref[@rid][@ref-type="bibr"][italic]/text()</code>
								it contains comma (e.g. Amass<italic>et al.</italic>, 2000), may be wrapped in a <code>attrib</code> element and there is also an inconsistency with the usage of "(" and ")" as separators (sometimes there are, sometimes do not). e.g. <a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31532339/fullTextXML">31532339</a>
								[ATM extracting only single pointers, ignoring separators and parent elements]
							</li>
							<li>
								<code>[<xref ref-type="bibr" rid="CR7">7</xref>, <xref ref-type="bibr" rid="CR10">10</xref>–<xref ref-type="bibr" rid="CR17">17</xref>]</code>
								meaning a list and a sequence in the same separator e.g. <a href="https://www.ebi.ac.uk/europepmc/webservices/rest/31243649/fullTextXML">31243649</a>. At the moment it's handled as a list, meaning that the intermediate (10-17) are not extracted
							</li>
						</ul>
					</div>
				</section>

				<!-- Section -->
				<section id="w13">
					<header>
						<h2>#w13</h2>
					</header>
					<div class="content">
						<p><strong>September 30, 2019 - October 4, 2019</strong></p>
						<h3>Integration of BEE, changes in graphlib according to the OCDM, others</h3>
						<p>I've integrated BEE with the extraction of intext references - now everything works. I'm still fixing some bugs/mistakes here and there (i.e. exceptions that I didn't take into account while processing PMC XMLs). My next step is to decide a pretty output for the bulk of data on reference pointers to be included in the definitive JSON. Hopefully, next week I'll work on SPACIN.</p>
					</div>
				</section>

				<!-- Section -->
				<section id="w12">
					<header>
						<h2>#w12</h2>
					</header>
					<div class="content">
						<p><strong>September 23 - September 27</strong></p>
						<h3>Completion of OCDM reference document</h3>
						<p>Still waiting for the last round of SP review.</p>
						<h3>Integration of bee, changes in graphlib according to the OCDM, others</h3>
						<p>Working on the detection of citation styles in the PMC OA corpus</p>
					</div>
				</section>



				<!-- Section -->
				<section id="w10-11">
					<header>
						<h2>#w10-11</h2>
					</header>
					<div class="content">
						<p><strong>September 11, 2019 - September 20, 2019</strong></p>

						<h3>Wrap up, completion of OCDM reference document</h3>
						<p><code>oco:hasAnnotation</code> inverse property of <code>oa:hasTarget</code>. The conversation in the community group <a href="http://lists.w3.org/Archives/Public/public-openannotation/2019Sep/subject.html">here</a>.</p>
						<h3>QUESTIONS</h3>
						<ul>
							<li>does the image of the extension go only on the online documentation? Uploaded in the oco ontology folder on github along with the core.png/graphml files.</li>
						</ul>

						<h3>TODO</h3>
						<h4>OCC document</h4>
						<ul><li>last round of review of S/D, names of citation functions</li></ul>

						<h4>OCO ontology</h4>
						<p>-</p>

						<h4>OCDM graph</h4>
						<p>-</p>

						<h4>C4O Ontology</h4>
						<ul>
							<li>Create the inverse property of <code>c4o:hasContext</code>, namely <code>c4o:isContextOf</code></li>
						</ul>

						<h4>Other documents online</h4>
						<ul>
							<li>Extend the technical documentation on the OCC model</li>
							<li>Modify the online documentation on the OCC website including the new extension</li>
						</ul>

						<h4>context.json, graphlib</h4>
						<ul>
							<li>change local context.json and graphlib according to definitive naming conventions in the doc</li>
							<li>Merge of Graphlib with changes made by FM</li>
							<li><strong>graphlib</strong> change/make new method <code>follows</code> - that is, oco:hasNext - to apply to other types of entities.</li>
							<li><strong>graphlib</strong> change contains_in_reference_list with something more general for including discourse elements</li>
						</ul>

						<h4>Code</h4>
						<ul>
							<li>make a regex in storer.py to distinguish reference/part (l.246-50, when rewrites the context URL)</li>
							<li>add a be2generic-citation link and every rp2specific-citation through an oa:Annotation; </li>
							<li>BEE test. Control whether the citation style is always the same in the corpus</li>
							<li>fork git (/script)</li>
						</ul>

						<h3>DONE</h3>
						<h4>OCC document</h4>
						<ul>
							<li>change the base URLs in the occ-doc json</li>
							<li>remove all labels</li>
							<li>next is only for pointers in list</li>
							<li>validate JSON and JSON LD</li>
							<li>formatting of JSON in doc</li>
							<li>modify JSON provenance (see metadata): remains se</li>
							<li>check OCI IDS everywhere</li>
							<li>br have prefixes! 0420</li>
							<li>NO content and xpath identifiers for pointers in list</li>
							<li>add all the cito properties for citation functions</li>
						</ul>
						<h4>OCO ontology</h4>
						<ul>
							<li>push on github</li>
							<li>add the image of the extension</li>
							<li>Add all the new properties from the extension</li>
							<li>Create <code>oco:hasAnnotation</code>, declare it as <code>oa:hasTarget</code> annotation</li>
							<li>Change range of <code>oco:hasNext</code> to <code>owl:Thing</code></li>
						</ul>
						<h4>context.json</h4>
						<h4>Other documents online</h4>
						<ul>
							<li>Modify the online documentation of the OCC website: “The RDF statements in each of the OpenCitations Indexes are <em>organising</em> according to the data model shown in Figure 2.”</li>
							<li>Modify the <a href="http://www.sparontologies.net/ontologies/c4o"><strong>online documentation of c4o</strong></a>: change the second <code>c4o:SingleReferencePointerList</code> with <code>c4o:SingleLocationPointerList</code>.</li>
						</ul>
						<h4>OCDM graph</h4>
						<ul>
							<li>change the OCDM graph, remove <code>oa:hasTarget</code> and add its inverse property <code>oco:hasAnnotation</code></li>
						</ul>
						<h4>Code</h4>
					</div>
				</section>

				<!-- Section -->
				<section id="w7">
					<header>
						<h2>#w7</h2>
					</header>
					<div class="content">
						<p><strong>August 18, 2019 - September 10, 2019</strong></p>

						<h3>Continue to work on the script for converting XML to RDF</h3>
						<p>Revised the idea of having a JSON as result of the XML parsing. Now it's a more <em>pythonic</em> list of lists (We might want to change it again so that it's nicely integrated in the JSON produced in Bee -- to be discussed in September). I created methods for reconciling entities to entites already existing in the graph (rp, de, xpath) and link them with each other. In september I'll continue on the integration of <code>br/be</code> to OCC. I've added the xpath of the text chunk (e.g. '[1]', '[1,2,3]') including the rp for disambiguating them when linking lists to their elements.</p>
						<p>Working on integrating the script in the workflow. In bee (<code>EuropeanPubMedCentralProcessor()</code>), I added a parameter <code>intext_refs=False</code> so that we can decide whether extract pointers or not. My guess is that we can extract them when the parameter <code>oa=True</code>. I've started testing the script <code>ccc/run.py</code> but I found the first problems (related to the <em>citation style</em> of in-text reference pointers). In spetmber I'll continue refining the script incrementally according to the cases I find (since there is no way ATM to predict which parent elements can include in-text reference pointers). </p>
						<h3>Extend the technical documentation on the OCC model extension including discussed CQs, SPARQL queries, and examples</h3>
						<p>Currently working on Bee/Spacin integration so as to create the toy data for supporting the data test.</p>
						<h3>TODO</h3>
						<ul>
							<li>[DONE] change "reference" in "part" in all the existing JSON-LD of the corpus</li>
						</ul>
					</div>
				</section>

				<!-- Section -->
				<section id="w6">
					<header>
						<h2>#w6</h2>
					</header>
					<div class="content">
						<p><strong>August 5, 2019 - August 11, 2019</strong></p>

						<h3>Continue to work on the script for converting XML to RDF</h3>
						<p>I have developed a draft script for obtaining a dictionary (JSON) including all the information that we want to transform in RDF. This week I'll extend it with the tranformation to RDF according to the extended OCC data model.</p>

						<h3>QUESTIONS</h3>
						<ul>
							<li>Should intermediate references in sequences be identified by some XPath too? e.g. the text between the two sibling <code>xref</code> elements that compose the range of the sequence? [no id/xpath for the pointers but only for the list]</li>

							<li>when I have a path like this <code>.//article/body/sec[1]/p[2]/fig/caption/p/xref[1]</code> or this <code>.//article/body/sec[3]/p[5]/table-wrap/table/tbody/tr[3]/td[2]/xref</code> what should I consider as parent? [p is the proper parent element, td becomes textchunk; add a conf file where I specify the conversion between xml elements to rdf entities]</li>

							<li>Should we extract also the section title? [yes]</li>

							<li>what other entities/attributes do we need to serialise for the br? expression type, title, authors, publisher, issue, volume ? only if the br is not already included in OCC? [crossref processor does the job if there is already that br in the OCC]</li>

							<li>shall we store also xpaths of sections and parent elements? [everything should be identified by XPath]</li>

						</ul>

						<h3>TODO</h3>
						<ul>
							<li>Control whether the citation style is always the same in the corpus</li>
							<li>fork git (/script)</li>
							<li><strong>graphlib</strong> change/make new method <code>follows</code> - that is, oco:hasNext - to apply to other types of entities. Can we have 2 aliases for the same property? [ok]</li>
							<li><strong>graphlib</strong> change contains_in_reference_list with something more general for including discourse elements</li>

						</ul>

						<h3>Extend the technical documentation on the OCC model extension including discussed CQs, SPARQL queries, and examples.</h3>
						<p>Working on that in a <a href="https://docs.google.com/document/d/1HZhS0wwPU5A30WJFJ9dAQezjJZ8i4bOuB6yyGPnFeLo/edit?usp=sharing">separate document</a>.</p>
						<p><strong>QUESTION</strong> Pointers can be also in section titles, should we include <code>doco:SectionTitle</code> among the DiscourseElemnts we consider? Should we create a SectionTitle for each section or only for the ones that include a pointer?</p>

						<h3>Work on the official document on the OC data model.</h3>
						<p>I have jotted down all the major changes that the document requires. All the changes are summarised in the abstract at the beginning of the document. I'll send the draft at the beginning of the week to get some preliminary feedback. Meanwhile, I will work on extending the JSON-LD example at the end of the document.</p>
						<p>Some points to be discussed:</p>
						<ul>
							<li><strong>Main changes</strong> I added a (redundant) summary of all the points where changes have been made.</li>
							<li><strong>RDF resources in OCC</strong> short names for in-text references and lists? <em>sp</em> and <em>lp</em>?</li>
							<li><strong>RDF resources in OCC</strong> the usage of <em>bibliographic entity</em> and its shortcut <em>en</em> is a bit misleading at the beginning of the document IMO, though it's clear the meaning.</li>
							<li><strong>Naming conventions</strong> We need to discuss on the naming of citation URIs, e.g. should they include the local identifier of an in-text references or the number representing the occurrence of a in-text reference?</li>
							<li><strong>Naming conventions</strong> The example provenance graph doesn't work. Is it fake? Did something change on the naming of these URIs?</li>
							<li><strong>Metadata elements</strong> I think there is a bit on the browsing features that should be updated.</li>
							<li><strong>Metadata elements</strong> I'd like to explain somewhere how the XPath works. Here it should not be mentioned to avoid a repetition. There is an example in the JSON linearisation, but no explanations. Do we need it or is it sufficient?</li>
							<li><strong>Mapping to OWL</strong> The URI of <code>co</code> ontology doesn't work.</li>
							<li><strong>Mapping to OWL</strong> Should we include the classes of <code>deo</code> for representing sections?</li>
							<li><strong>Mapping to OWL</strong> Do we need <code>rdf:type</code> for all the entities? I noticed this has been added only when there are subclasses.</li>
							<li><strong>Mapping to OWL</strong> Do we store the value of the in-text reference pointer? e.g. <em>Peroni et al., [1]</em></li>
							<li><strong>Mapping to OWL</strong> Do we need <code>oa:annotatedBy</code> since we have the provenance graph?</li>
							<li><strong>JSON linearisation</strong> Best prefix for the <em>real</em> citation graph? I proposed <code>gcip</code> which mixes citation and in-text-ref pointers.</li>
							<li><strong>JSON linearisation</strong> The alias of <code>frbr:part</code>, i.e. <em>reference</em> is misleading, because we use it also for the hierarchy of discourse elements</li>
							<li><strong>JSON linearisation</strong> Should we add all the cito properties in the aliases?</li>
							<li><strong>JSON linearisation</strong> I added an excerpt on in-text ref and sentences in the section dedicated to <em>bibliographic resources</em>, and I modified the section <em>citations</em> to include annotations. I created here two examples (citations with annotations and without). I have some concerns here about the IRI of the graphs.</li>
							<li><strong>JSON linearisation</strong>: I added only an example of sentence/in-text reference pointer. I didn't add other discourse elements, nor lists. Is that ok or do we want a complete example? Can I use eventually ellipses [...] to skip redundant and repetitive code?</li>
						</ul>

						<h3>TODO</h3>
						<ul>
							<li>Change JSON example in occ doc. Reproduce the tree of discourse elements</li>
							<li>Extend the <a href="https://w3id.org/oc/corpus/context.json">context.JSON</a> of the OCC model</li>

							<li>Modify the <a href="http://www.sparontologies.net/ontologies/c4o"><strong>online documentation of c4o</strong></a>: change the second <code>c4o:SingleReferencePointerList</code> with <code>c4o:SingleLocationPointerList</code>.</li>

							<li>Modify the online documentation of the OCC Model: “The RDF statements in each of the OpenCitations Indexes are <em>organising</em> according to the data model shown in Figure 2.”</li>

							<li>Modify domain/range of the <code>oc:hasNext</code> property</li>

							<li>Create the inverse property in c4o <code>c4o:hasContext</code> > <code>c4o:isContextOf</code></li>

							<li>[NO] Create <code>datacite:xpath</code> individual.</li>

							<li>Modify documentation of the OCC also on github</li>

							<li>Fork opencitations/script</li>

						</ul>

					</div>
				</section>

				<!-- Section -->
				<section id="w5">
					<header>
						<h2>#w5</h2>
					</header>
					<div class="content">
						<p><strong>July 28, 2019 - August 4, 2019</strong></p>
						<h3>Continue to work on the script for converting XML to RDF</h3>
						<p><strong>JSON of extraction results</strong> I got my JSON including xrefs, grouped in (1) lists, (2) sequences, or (3) singletons, and I extended sequences with intermediate xrefs. The JSON is a list of lists (each list represents one of the three aforementioned groups), including dictionaries for each xref that is part of the group. It is organised as follows:</p>
							<pre>
								<code>
[...
[{'articleDOI': '10.1042/BST20170265',
   'bibRefUID': '10.1016/S0006-3495(02)73903-9',
   'xrefElemSentenceXPath': 'substring(string(.//article/body/sec[3]/p[8]),225,170)',
   'xrefElemXPath': './/article/body/sec[3]/p[8]/xref',
   'xrefParentElem': 'p',
   'xrefParentElemXPath': './/article/body/sec[3]/p[8]',
   'xrefValue': '42'},
  'singleton'],
 [{'articleDOI': '10.1042/BST20170265',
   'bibRefUID': '10.1371/journal.pone.0064567',
   'xrefElemSentenceXPath': 'substring(string(.//article/body/sec[4]/title),1,29)',
   'xrefElemXPath': './/article/body/sec[4]/title/xref[1]',
   'xrefParentElem': 'title',
   'xrefParentElemXPath': './/article/body/sec[4]/title',
   'xrefValue': '36'},
  {'articleDOI': '10.1042/BST20170265',
   'bibRefUID': '10.1038/msb4100131',
   'xrefElemSentenceXPath': 'substring(string(.//article/body/sec[4]/title),1,29)',
   'xrefElemXPath': './/article/body/sec[4]/title/xref[2]',
   'xrefParentElem': 'title',
   'xrefParentElemXPath': './/article/body/sec[4]/title',
   'xrefValue': '48'},
  'list'],
 [{'articleDOI': '10.1042/BST20170265',
   'bibRefUID': '10.3389/fmicb.2016.00673',
   'xrefElemSentenceXPath': 'substring(string(.//article/body/sec[4]/p[1]),227,75)',
   'xrefElemXPath': './/article/body/sec[4]/p[1]/xref[2]',
   'xrefParentElem': 'p',
   'xrefParentElemXPath': './/article/body/sec[4]/p[1]',
   'xrefValue': '37'},
  {'articleDOI': '10.1042/BST20170265',
   'bibRefUID': '10.3389/fmicb.2015.00213',
   'xrefElemSentenceXPath': 'substring(string(.//article/body/sec[4]/p[1]),227,75)',
   'xrefElemXPath': './/article/body/sec[4]/p[1]/xref[3]',
   'xrefParentElem': 'p',
   'xrefParentElemXPath': './/article/body/sec[4]/p[1]',
   'xrefValue': '39'},
  'sequence',
  {'articleDOI': '10.1042/BST20170265',
   'bibRefUID': '10.3389/fgene.2017.00088',
   'xrefElemSentenceXPath': 'substring(string(.//article/body/sec[4]/p[1]),227,75)',
   'xrefElemXPath': 'none',
   'xrefParentElem': 'p',
   'xrefParentElemXPath': './/article/body/sec[4]/p[1]',
   'xrefValue': '38'}],
...]
								</code>
							</pre>

						<p>Notice that intermediate nodes in sequences DO NOT have their own XPath, while they share the same parent XPath and the sentence XPath. </p>
						<p><strong>Bye bye XPointer for in-text reference pointers?</strong> The Xpath function <a href="https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/string"><code>string()</code></a> (XPath 1.0) allows to select the text of a node, ignoring (better, stripping) all children tags, but not their content. We can apply <code>string()</code> to the XPath of the parent element of the <code>xref</code> at hand, and use the XPath of the parent element text as first parameter of the XPath function <a href="https://developer.mozilla.org/en-US/docs/Web/XPath/Functions/substring"><code>substring($string, $start, $end)</code></a> . For instance, <code>substring(string(.//article/body/sec[5]/p[2]), 1, 10)</code> selects the first 10 characters in the paragraph <code>p[2]</code>, regardless there are intermediate nodes. It's formally wrong since the first paramenter of <code>substring</code> should be a string, and not a path to get the string, but substituting that path with the original text is possibly the easiest way to access the content regardless the environment (XSLT, python, whatever) rather than using XPointer, that is not supported by any library or language. Can we specify it somewhere?</p>
						<h3>Extend the technical documentation on the OCC model</h3>
						<p>Included the defintions requested by D.</p>
						<h3>Work on the official document on the OC data model</h3>
						<p>On it.</p>
						<h3>QUESTIONS / TO BE DISCUSSED</h3>
						<ul>
							<li>Should intermediate references in sequences be identified by some XPath too? e.g. the text between the two sibling <code>xref</code> elements that compose the range of the sequence?</li>
							<li>Found the <a href="https://www.ncbi.nlm.nih.gov/pmc/tools/oai/#examples">OAI-PMH service</a>. Use the parameter <code>set=pmc-open</code> for the papers for whom we can harvest the full text too.</li>
							<li>when I have a path like this <code>.//article/body/sec[1]/p[2]/fig/caption/p/xref[1]</code> or this <code>.//article/body/sec[3]/p[5]/table-wrap/table/tbody/tr[3]/td[2]/xref</code> what should I consider as parent? </li>
							<li>[SOLVED] The NLTK tokeniser behaviour is different from the one of XPath, hence returned offsets are somehow wrong (and it's not because of the 0/1-based indexing). Need to figure out why and work on it.</li>
						</ul>
					</div>
				</section>

				<!-- Section -->
				<section id="w4">
					<header>
						<h2>#w4</h2>
					</header>
					<div class="content">
						<p><strong>July 19, 2019 - July 25, 2019</strong></p>
						<h3>Review of comments on the OCC model extension</h3>
						<p>I've answered/resolved almost all comments in the docs. I left few of them to clarify some points to D.</p>
						<p>L.W. comments on citation/reference functions made me think we need to represent <code>c4o:InTextReferencePointer</code> always, even when these are in lists (see below). D.S. added comments on the terminology and the workplan</p>
						<h3>Draft of the model</h3>
						<p>Available <a href="occ_model_ext/graphs/OCC_extended.png">here</a>.</p>
						<h3>Jot down the script for converting XML to RDF</h3>
						<p>Giovanni's work <a href="http://context-miner.monsieurcube.com">ContextMiner</a>.</p>
						<p>Working on that <a href="occ_model_ext/scripts/jats2oc.py">here</a>.</p>
						<p>To modularise the code I'd (1) preprocess the xml files and create a JSON including all the information we need in order to secondly (2) reconcile DOIs and IDs to OC URIs, and (3) transform data to RDF.</p>
						<h3>TODO</h3>
						<ul>
							<li>Review D.'s comments and modify google docs and workplan (here).</li>
							<li>Modify OC and SPAR documentation (waiting for access rights to git)</li>
						</ul>
						<h3>Questions/ To be discussed</h3>
						<ul>
							<li>D.'s Comments to the google doc.
								<ul>
									<li><strong>Text chunks</strong>: if we do not extract clean sentences we may want to use this. We should use it anyway for footnotes, table cells, and captions. Should we add the definition in the documentation? [SOLUTION] Use text chunk only for table cells.</li>
									<li><strong>xPointer and xPath</strong> define them in the docs. [DONE]</li>
									<li><em>avoid the possibility of a paper having two in-text pointer lists with the same number (e.g. "l1"), distinguished only by their location.</em>. Should the lists identifiers be only incremental? Why not distinguished by location? [SOLUTION] incremental</li>
									<li><em>You might also wish to add a functionality that returns a list of references in terms of the number of in-text reference pointers each receives, either for the document as a whole, or for each section.</em> [SOLUTION] add new CQ</li>
									<li><em>Also, a functionality to order the in-text reference pointer lists in terms of the number of in-text reference pointers each contains (although I think this would be of more limited usefulness).</em> [SOLUTION] add new CQ</li>
									<li><em>Additionally, it would be good to be able to document all the different citation functions ascribed to each reference, by amalgamating the citation function annotations for each in-text reference pointer to that reference.</em>[TODO] write D. whether it's possibly CQ2.1 or something else.</li>
									<li>develop a separate extraction script, CCE (Citation Context Extraction), specifically for your purpose. [TODO] write D. OK. Independent module reused by BEE</li>
									<li>I think that you should store your RDF in a new Blazegraph triplestore called Citations in Context Corpus (CCC), not in OCC. [TODO] write D. : corpus as a sandbox with toy data. Then a bespoke triplestore.</li>
									<li><em>I think this is much too late to undertake deployment of the workflow and extending browse and query functionality, since you will inevitably run into implementation problems and run out of time.  Rather, both these activities should be completed (at least in prototype) before you visit Leiden and Hinxton, so that you have something to demonstrate and modify in response to the feedback you receive.</em> </li>
									<li> Project timescale.  In light of these comments, I think you should revise your workplan by moving things forward, as shown:
										<ul>
											<li>EXTENDING THE OPENCITATIONS DATA MODEL   July 1, 2019 - August 15, 2019 [TODO] explain why september. before 20 August I send (1) drat of the model, (2) the documentation (with query and examples w/ some toy data), and (3) the draft document. </li>
											<li>TEXT MINING AND ONTOLOGY EVALUATION  August 15, 2019 - September 30, 2019</li>
											<li>EXTRACTION AND INGESTION WORKFLOW  October 1, 2019 - February 1, 2020</li>
											<li>DEPLOY WORKFLOW AND DEVELOP INTERFACES FOR OCC   March 1, 2020 - March 31, 2020 [TODO] testing here, while in production in June</li>
											<li>VISITING PERIODS AND API TUNING   March 1, 2020 - April 30, 2020</li>
											<li>UPDATE FUNCTIONALITY; WRITE UP PROJECT   June 1, 2020 - June 30, 2020</li>
										</ul>

									</li>
								</ul>
							</li>
							<li>Best way to <strong>reconcile</strong> articles to existing OC Ids (URI)? In particular:
								<ul>
									<li><code>biro:BibliographicReference</code></li>
									<li><code>fabio:Expression</code> representing the citing/cited article</li>
								</ul>
								[TO BE DISCUSSED LATER]
							</li>
							<li><strong>Lists of in-text reference pointers</strong> should include all the in-text reference pointers or not? After Ludo mentioned the distinction between reference/citation function I guess we need in-text ref pointers always (whether in lists or not, because these are the body of the <code>oa:Annotation</code> when representing the citation function). That is:
								<ul>
									<li>we have 1 to 1 relation between <code>cito:Citation</code> and <code>fabio:Expression/biro:BibliographicReference</code></li>
									<li>we have 1 to n relations between <code>cito:Citation</code> and <code>oa:Annotation</code>, i.e. as many as the number of <code>c4o:InTextReferencePointer</code> denoting the same <code>fabio:Expression/biro:BibliographicReference</code></li>
								</ul>
							If we have several pointers denoting the same bibliographic reference that appear in lists, or sequences, and single ref. pointers at the same time, we always need a <code>c4o:InTextReferencePointer</code> to be explicitly represented, since the body of a <code>oa:Annotation</code> is the pointer, not the list/sequence. [SOLUTION] we keep all the in-text references
							</li>
							<li><strong>The citation deadlock</strong>. Since the instance of <code>cito:Citation</code> is always one between citing/cited paper, but several in-text references may occur with different citation functions, hence there may be several annotations between the citation and different in-text pointers, what should we associate as domain to the property <code>cito:hasCitationCharacterization</code>? Possibilities:
								<ul>
									<li>use instead <code>oa:motivatedBy</code> for characterizing the annotation rather than the citation itself? (which sounds odd anyway, since it's not the intended sense of the property)</li>
									<li>create as many <code>cito:citation</code> as the number of in-text references, and then the domain of <code>cito:hasCitationCharacterization</code> is <code>cito:Citation</code></li>
									<li>annotate the <code>oa:Annotation</code> with both the <code>cito:Citation</code> and the citation function as <code>oa:hasTarget</code> [I vote for this]</li>
								</ul>
							[SOLUTION] We create as many <code>cito:Citation</code>	as the number of in-text ref pointers and we characterize that rather than the <code>oa:Annotation</code>
							</li>
							<li>When in-text ref are in table cells, should we store the xPath of the table rather than the <strong>xPointer of the cell/row/column</strong>? or the xPointer of the whole table? [SOLUTION] only the cell</li>
							<li><strong>XPointers</strong> I'm struggling to find good libraries for extracting them. [see DOM Range and DOM Fragments].</li>
							<li><code>hasBody</code> and <code>hasTarget</code> should be swapped (look better OA model)</li>

							<li>[POSTPONED] We have only the <strong>zip files of the PMC nxml</strong>. We need the API</li>
							<li>[POSTPONED] Any particular requirement in terms of encoding?</li>
							<li>[TODO] Modify the <a href="http://www.sparontologies.net/ontologies/c4o"><strong>online documentation of c4o</strong></a>: change the second <code>c4o:SingleReferencePointerList</code> with <code>c4o:SingleLocationPointerList</code>.</li>

							<li>[TODO] Modify the online documentation of the OCC Model: “The RDF statements in each of the OpenCitations Indexes are <em>organising</em> according to the data model shown in Figure 2.”</li>

							<li>[TODO] Modify domain/range of the <code>oc:hasNext</code> property</li>

							<li>[TODO] Create the inverse property in c4o <code>c4o:hasContext</code> > <code>c4o:isContextOf</code></li>
							<li>[TODO] in the model change <code>dcterms:bibliographicCitation</code> with <code>c4o:hasContent</code></li>
						</ul>

					</div>
				</section>

				<!-- Section -->
				<section id="w1">
					<header>
						<h2>#w1</h2>
					</header>
					<div class="content">
						<p><strong>July 1, 2019 - July 8, 2019</strong></p>
						<h3>workplan</h3>
						<p>The workplan is set up, the timing assigned to scheduled activities seem doable. Some parts are still to be defined (like the visiting periods and the related activities). I emailed the general plan to all the project members.</p>
						<p>We agreed that the result of the first phase will result in the extension of the OCC data model, which requires us to:</p>
						<ul>
							<li>modify the OC Ontology</li>
							<li>modify the official documentation (docx)</li>
							<li>modify the online documentation on the OCC website</li>
						</ul>
						<h3>collaborative environment</h3>
						<p>I created a shared folder in google drive called <strong>OCC_DM_Extension</strong> (shared with Silvio and David only, via email) including:</p>
						<ul>
							<li>the <a href="https://docs.google.com/document/d/1HZhS0wwPU5A30WJFJ9dAQezjJZ8i4bOuB6yyGPnFeLo/edit?usp=sharing">technical documentation</a> for the extension of the OC Ontology. This include motivating scenarios, competency questions, definitions, and a draft of the model. This is the document we will share with all the partners for collecting suggestions and feedback on competency questions.</li>
							<li>a preliminary graph in graphml, also included in the former document</li>
							<li>a <a href="https://drive.google.com/file/d/1pOSI4_cpYcrg4F202UEBO7tPlOUgQhTp/view?usp=sharing">google docs version (view only)</a> of the official documentation of the OCC data model called <strong>occ-metadata-v1_6</strong></li>
						</ul>
						<h3>Competency questions, definitions, literature review</h3>
						<p>I think I found a good number of relevant CQs that the model should be able to answer. More may come from suggestions. I have some concerns, namely:</p>
						<ul>
							<li><em>[ADDED TO TODO LIST]</em> There are bits of the <a href="http://www.sparontologies.net/ontologies/c4o"><strong>online documentation of c4o</strong></a> that seem odd to me and I might have misunderstood something. For instance the double definition of <code>c4o:SingleReferencePointerList</code>. The second one seems to refer to <code>c4o:SingleLocationPointerList</code>, but this concept is still a bit fudged to me. However, I think it's not relevant for the purpose. </li>

							<li><em>[SORTED]</em> In <a href="http://www.sparontologies.net/ontologies/doco">DoCO</a> the representation of <strong>sentences</strong> and in-text references is slightly different from the one in c40. For instance, in example 2, an in-text reference pointer is defined as an individual of the class <code>deo:Reference</code>, not a <code>c4o:InTextReferencePointer</code>, which <code>dcterms:references</code> (and not <code>biro:references</code> as in c4o) a <code>deo:BibliographicReference</code> (and not a <code>biro:BibliographicReference</code>) </li>

							<li><em>[SORTED]</em> When we have <strong>lists of in-text ref pointers</strong>, do we really need the intermediate node <code>c4o:InTextReferencePointerListItem</code>? In this case I don't get the added value of having yet another class. The latter is not documented online, so I might have missed why it is relevant. Plus, I din't get <code>c4o:pertainsTo</code>.</li>

							<li><em>[TO BE DISCUSSED]</em> Do we need to represent the <strong>order of pointers</strong> in the list?</li>

							<li><em>[SORTED]</em> Document components to be taken into account are <strong>sentences, paragraphs and sections</strong>. In the first case, we are not sure of the quality of data extracted from XML documents. Hence, it might worth to consider the class <code>doco:TextChunk</code>. However, this is meant to represent an inline string. Secondly, if we are not sure whether we will extract sentences or not, maybe it worths to create also the link between <code>c4o:InTextReferencePointer / c4o:InTextReferencePointerList</code> and <code>doco:Paragraph</code> by means of <code>c4o:hasContext</code>.</li>

							<li><em>[SORTED]</em> The <strong>hierarchy of document components</strong>. I'd avoid to use yet another (unstable) pattern, such as the one suggested in DoCo, namely: <code>po:contains</code>. Can't we use <code>frbr:part</code>?</li>

							<li><em>[TO BE DISCUSSED]</em> <strong>Represent xpath</strong> of document components. I found a property in <a href="https://schema.org/xpath">schema.org</a> which could be reused to preserve the xpath as a literal. </li>

							<li><em>[SORTED]</em> We agreed that the <strong>order of paragraphs</strong> worths to be preserved in data, but only the relation between paragraphs including citations will be represented and stored. We will design URI patterns for paragraphs and other document components that will allow users to easily rebuild the correct order of all the paragraphs. The <code>oc:hasNext</code> property can be reused for representing the sequences. However (1) in DoCo is suggested <code>co:firtsItem/co:nextItem/co:itemContent</code> (which is somehow cumbersome and would require to create other intermediate nodes) and (2) the aforementioned <code>oc:hasNext</code> property has as a declared domain/range <code>pro:RoleInTime</code>.</li>

							<li><em>[SORTED]</em> When characterising the <strong>type of sections</strong>, should we reuse terms from <code>doco</code>, <code>deo</code>, and <code>po</code> ontologies (e.g. Abstract, RelatedWork, Methods)? Or should we create a controlled vocabulary of individuals representing types?</li>

							<li><em>[SORTED]</em> When representing <strong>titles of sections</strong>, instead of the suggested pattern <code>po:containsAsHeader/c4o:hasContent</code> we could just use <code>dcterms:title</code>.</li>
						</ul>

						<h3>TO BE DISCUSSED</h3>
						<ul>
							<li>In the examples provided in <a href="http://www.sparontologies.net/ontologies/cito">CiTo</a> about annotating citations with the OA model, there is an inconsistency. The <code>cito:Citation</code> is the target of the annotation, while the in-text ref. pointer is the body. Correct? If so, the <a href="http://dx.doi.org/10.6084/m9.figshare.1512817">second example</a> contradicts the first one (where the in-text ref pointer is considered the target of the annotation, and the citation is deemed the body of the annotation).</li>
							<li>How to represent properties as individuals in graffoo?</li>
							<li>Functions of Citations Ontology is mentioned twice in CiTO documentation, but both the links, i.e. <a href="http://www.sparontologies.net/ontologies/foco">link1</a> and <a href="http://www.essepuntato.it/2013/03/cito-functions">link2</a>, are broken.</li>
							<li>the Purl of co Ontology gives a 404 not found!</li>
							<li>Do we consider in-text reference pointers in tables, captions and footnotes too?</li>
							<li>Do we really need to use <code>literal:hasLiteralValue</code>?</li>
							<li>There are no inverse properties in the <code>OA data model</code></li>
						</ul>

						<h3>TODO</h3>
						<ul>
							<li>email David to start discussing the tech. doc. first. The official documentation (docx) will be modified as last thing.</li>

							<li>Modify the <a href="http://www.sparontologies.net/ontologies/c4o"><strong>online documentation of c4o</strong></a>: change the second <code>c4o:SingleReferencePointerList</code> with <code>c4o:SingleLocationPointerList</code>.</li>

							<li>Modify the online documentation of the OCC Model: “The RDF statements in each of the OpenCitations Indexes are <em>organising</em> according to the data model shown in Figure 2.”</li>

							<li>Modify domain/range of the <code>oc:hasNext</code> property</li>

							<li>Create the inverse property in c4o <code>c4o:hasContext</code> > <code>c4o:isContextOf</code></li>
						</ul>

						<h3>DISCUSSED/DONE</h3>
						<ul>
							<li>agreed on how to represent:
								<ol>
									<li>hierarchies of document components. We decided to use <code>frbr:part</code> for everything instead of <code>po:contains</code>.</li>
									<li>sequences of document components. We decided to change domain and range of the <code>oc:hasNext</code> property, which can be used for both document components and, eventually in-text reference pointers in lists</li>
									<li>titles of sections (dcterms:title or the longer pattern?). We decided to use <code>dcterms:title</code></li>
									<li>types of sections (use classes from DoCO, deo ontologies or create a vocabulary). We decided to use DoCO and deo classes, specifically for structural elements and semantic elements (types of section)</li>
									<li>xpaths (schema.org property or different data/annotation property?). We refer to xPointers rather than xPaths and we decided to use <code>datacite:Identifier</code>, having as rdf:value the string representing the xPointer and as schema the xPointer scheme.</li>
									<li>whether to use <code>c4o:InTextReferencePointerListItem</code> as intermediate node or not in lists of in-text ref. pointers or not. We decided not to use <code>c4o:InTextReferencePointerListItem</code> AND not to use <code>c4o:InTextReferencePointerList</code>. Instead we use <code>c4o:SingleLocationPointerList</code> for lists, linked (eventually, to be decided) to <code>c4o:InTextReferencePointer</code> by means of the property <code>co:element</code>. The latter depends on the need to represent the order of pointers in lists. Otherwise the linke between <code>c4o:SingleLocationPointerList</code> and <code>biro:BibliographicReference</code> by means of <code>c4o:pertainsTo</code> should be sufficient to retrieve everything we need, avoiding to create redundant data.</li>

									<li>whether use <code>doco:Sentence</code> or <code>doco:TextChunk</code>. We agreed that <code>doco:TextChunk</code> fits better the purpose, semantically speaking (since we may end up looking for chunks indeed), but it's less understandable tough.</li>
									<li>whether to create links (<code>c4o:hasContext</code>) between pointers and sentences or between pointers and paragraphs. We decided to create links between pointers and textChunk BUT using the inverse property <code>c4o:isContextOf</code> that has to be created in c4o.</li>
									<li>whether to represent the order of pointers in lists (connected to point 2). We will discuss it according to real needs.</li>
								</ol>
							</li>
							<li>email everybody the doc with CQ, explaining how to contribute</li>
						</ul>
					</div>
				</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
